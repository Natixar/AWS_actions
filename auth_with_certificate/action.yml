# action.yml
name: 'Setup AWS authentication credentials with Certificate'
description: 'Setup AWS CLI and authenticate using an X509 certificate'

inputs:
  # The certificate contains the public key and identity of the requestor
  # linked together by a signature made using the private key. The private
  # key can be generated by the requestor directly in the security module 
  # used to sign the requests to AWS later on. The certificate is supplied
  # by a Certification Authority, which is in charge of 
  certificate_content:
    description: 'Public certificate content'
    required: true
    
  private_key:
    description: 'The content of the private key. Store it in GitHub secrets.'
    required: true

  # Each role has at last one trust anchor attached, which is an intermediate
  # Certification Authority. You must provide the role and the reference
  # of the corresponding trust anchor. This is not a secret. The certificate
  # above must also be signed by the trust anchor.
  role_arn:
    description: 'Role ARN to assume'
    required: true
    
  trust_anchor_arn:
    description: 'Trust anchor ARN for AWS IAM Roles Anywhere'
    required: true

  # All the roles are defined in the same profile. 
  # The privileges are defined by roles.
  # Roles segregate privileges for two reasons:
  # - downstream: running AWS functions and lambdas with minimum privileges
  # - upstream: distinct remote users
  # All the final entity certificates signed by the same intermediate CA have
  # the same privileges, since roles reference intermediate CAs. If multiple
  # entities use the same backend service, they have distinct certificates 
  # signed by the same CA, and CloudTrail logs which one is used, but they
  # have exactly the same rights.
  # If an entity needs several backend services, it may have to use several
  # distinct certificates, up to one by service.
  # Groups of backend services used together have a dedicated intermediate CA
  # and legitimate users of these groups get certificates signed by that CA.
  # Groups of backend services may have more than one intermediate CA.
  # We also create intermediate CAs for subcontractors and we add them to the
  # list of trust anchors of the roles that those subcontractors must use. Once
  # subcontractors have finished their work, their certificates are revoked and
  # we can keep the same CA with new certificates for operations.
  profile_arn:
    description: 'Profile ARN for AWS IAM Roles Anywhere'
    required: true
    default: 'arn:aws:rolesanywhere:eu-west-3:975050054945:profile/50cf35cc-f896-454f-b084-e208790dd328'

  # The AWS signing helper generates a properly signed request and passes the
  # certificate to AWS for verification. It returns short lived credentials.
  # The default values should be fine, but should the helper evolve, they can
  # be adjusted here.
  aws_signing_helper_download_link:
    description: 'Source URL for the Linux binary of the AWS signing helper'
    required: true
    default: 'https://rolesanywhere.amazonaws.com/releases/1.1.1/X86_64/Linux/aws_signing_helper' 
    
  aws_signing_helper_sha256:
    description: 'SHA256 checksum for the AWS signing helper binary'
    required: true
    default: '3761071497510ae1bde82aa31e34bbb63b9701deb932434e786a8479062b2b9b'

outputs:
      access_key_id:
        description: 'AWS Access Key ID'
        value: ${{ steps.aws_helper.outputs.aws_access_key_id }}
      secret_access_key:
        description: 'AWS Secret Access Key'
        value: ${{ steps.aws_helper.outputs.aws_secret_access_key }}
      session_token:
        description: 'AWS Session Token'
        value: ${{ steps.aws_helper.outputs.aws_session_token }}
    
runs:
   using: 'composite'
   steps:
      - name: Install dependencies
        run: |
          if ! command -v aws &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y awscli jq
          elif ! command -v jq &> /dev/null; then
            sudo apt-get update && sudo apt-get install -y jq
          fi
        shell: bash
      
      - name: Download and verify AWS Signing Helper
        run: |
          curl -L "${{ inputs.aws_signing_helper_download_link }}" -o aws_signing_helper
          echo "${{ inputs.aws_signing_helper_sha256 }}  aws_signing_helper" | sha256sum -c -
          chmod +x aws_signing_helper
        shell: bash
      
      - name: Configure AWS CLI and Authentication
        id: aws_helper
        run: |
          echo "${{ inputs.certificate_content }}" > aws_cert.pem
          echo "${{ inputs.private_key }}" > aws_key.pem
          ./aws_signing_helper credential-process \
            --certificate aws_cert.pem \
            --private-key aws_key.pem \
            --profile-arn "${{ inputs.profile_arn }}" \
            --role-arn "${{ inputs.role_arn }}" \
            --trust-anchor-arn "${{ inputs.trust_anchor_arn }}" > aws_credentials.json
          # Need local variables to mask credentials
          access_key="$(jq -r '.AccessKeyId' aws_credentials.json)"
          secret="$(jq -r '.SecretAccessKey' aws_credentials.json)"
          token="$(jq -r '.SessionToken' aws_credentials.json)"
          echo "::add-mask::$access_key"
          echo "::add-mask::$secret"
          echo "::add-mask::$token"
          echo "AWS_ACCESS_KEY_ID=$access_key" >> "$GITHUB_OUTPUT"
          echo "AWS_SECRET_ACCESS_KEY=$secret" >> "$GITHUB_OUTPUT"
          echo "AWS_SESSION_TOKEN=$token"      >> "$GITHUB_OUTPUT"
        shell: bash
        
      - name: Clean up and tell GitHub to mask the secrets
        if: always()
        run: |
          rm -f aws_cert.pem aws_key.pem aws_signing_helper aws_credentials.json
        shell: bash
        
